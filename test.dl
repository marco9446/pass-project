.type label
.type var
.type opc = [x:number,c:number]
.type opv = [x:number,y:number]
//.type expr //= number | var | opc | opv
//.type cond //= [e:expr,constyp:number]// assume 1 for <, 2 for <= and 3 
// for ==, 4 for >= and 5 for >

// -- inputs --
.decl source( l:label, x:var )
.decl sink( l:label, x:var ) 
.decl follows( l1:label, l2:label) 

.decl join(l1: label, l2: label, l3:label) 
.decl assign( l:label, x:var, y:var, z:var ) 
.decl if(l1:label, l2:label, x:var, y:var)

source("l1","x").

sink("l18","x").	

follows("l2","l1").
follows("l3","l2").
follows("l4","l3").
follows("l5","l4").
follows("l6","l2").
follows("l7","l6").
follows("l8","l7").
follows("l9","l5").
follows("l9","l8").
follows("l10","l1").
follows("l11","l10").
follows("l12","l11").
follows("l13","l12").
follows("l14","l10").
follows("l15","l14").
follows("l16","l15").
follows("l17","l13").
follows("l17","l16").
follows("l18","l9").
follows("l18","l17").

join("l9","l5","l8").
join("l17","l13","l16").
join("l18","l9","l17").

assign("l4","x","y","z").
assign("l7","u","0","0").
assign("l12","u","y","0").
assign("l15","u","z","0").


if("l2","l3","y","0").
if("l3","l4","z","0").
if("l6","l7","z","0").
if("l10","l11","y","0").
if("l11","l12","z","0").
if("l14","l15","z","0").


.decl Labels(i:label )
.output Labels(IO=stdout)
Labels(l) :- source(l,_).
Labels(l) :- follows(l,_).
Labels(l) :- follows(_,l).


/**
*   The Numbers function strips the labes in order to optain only the number of
*   lines, ignoring the first character 
*/
.decl Numbers(i:symbol )
.output Numbers(IO=stdout)
Numbers( substr(x,1,strlen(x)-1) ) :- Labels(x), strlen(x) > 1.


.decl smart_mica_tanto(l:label, n:number)
.output smart_mica_tanto(IO=stdout)
smart_mica_tanto(l1, n) :- follows(_, l1), !follows(l1, _), n=1.
smart_mica_tanto(l2, n+1) :- smart_mica_tanto(l1, n), follows(l2, l1) ,!super_if_else(_, l2, _).
smart_mica_tanto(l2, n) :- smart_mica_tanto(l1, n), follows(l2, l1) ,super_if_else(_, l2, _).


.decl reachable(l:label, j:label)
// .output reachable(IO=stdout)
reachable(X,Y)  :-  follows(X,Y).
reachable(X,Y)  :-  reachable(X,Z), follows(Z,Y).


.decl super_if_else(i:label, e:label, j:label) 
.output super_if_else(IO=stdout)
super_if_else(i,e,j) :- if(i, _ ,x,y), if(e, _ ,x,y), join(j, ij ,ej), 
                !follows(e, ij), 
                follows(j, ej), 
                i != e, 
                reachable(ij, i), 
                reachable(ej, e),
                follows(i, l2), follows(e, l2).



// .decl gianni(l:symbol, n:number)
// .output gianni(IO=stdout)
// gianni(l, n):- Labels(l), follows(_, l), !follows(l, _), n = 1.
// gianni(l, n+1):- gianni(l, n), Labels(l), follows(_, l).
