// Authors: Marco Ravazzini & Flavia Cavallaro
//          with the partecipation of Calcutta




.type label
.type var
.type opc = [x:number,c:number]
.type opv = [x:number,y:number]
//.type expr //= number | var | opc | opv
//.type cond //= [e:expr,constyp:number]// assume 1 for <, 2 for <= and 3 for ==, 4 for >= and 5 for >

// -- inputs --
.decl source( l:label, x:var )
.decl sink( l:label, x:var ) 
.decl follows( l1:label, l2:label) 

.decl join(l1: label, l2: label, l3:label) 
.decl assign( l:label, x:var, y:var, z:var ) 
.decl if(l1:label, l2:label, x:var, y:var)

//L2: if (y > 0){
//L3:  if(z > 0){
//L4:  u:=x;
//L5:  }
//L6:  else{
//L7:   u:=0;
//L8:  }
//L9: }  
//L10: else{
//L11:   if(z>0){
//L12:      u:=y;
//L13:   }
//L14:   else{
//L15:      u:=z;
//L16:   }
//L17:  }
//L18: sink(u);  

// source("l1","x").

// sink("l18","u"). 

// follows("l2","l1").
// follows("l3","l2").
// follows("l4","l3").
// follows("l5","l4").
// follows("l6","l2").
// follows("l7","l6").
// follows("l8","l7").
// follows("l9","l5").
// follows("l9","l8").
// follows("l10","l1").
// follows("l11","l10").
// follows("l12","l11").
// follows("l13","l12").
// follows("l14","l10").
// follows("l15","l14").
// follows("l16","l15").
// follows("l17","l13").
// follows("l17","l16").
// follows("l18","l9").
// follows("l18","l17").

// join("l9","l5","l8").
// join("l17","l13","l16").
// join("l18","l9","l17").

// assign("l4","u","x","0").
// assign("l7","u","0","0").
// assign("l12","u","y","0").
// assign("l15","u","z","0").


// if("l2","l3","y","0").
// if("l3","l4","z","0").
// if("l6","l7","z","0").
// if("l10","l11","y","0").
// if("l11","l12","z","0").
// if("l14","l15","z","0").

source("l1","x").

sink("l18","u").	

follows("l2","l1").
follows("l3","l2").
follows("l4","l3").
follows("l5","l4").
follows("l6","l2").
follows("l7","l6").
follows("l8","l7").
follows("l9","l5").
follows("l9","l8").
follows("l10","l1").
follows("l11","l10").
follows("l12","l11").
follows("l13","l12").
follows("l14","l10").
follows("l15","l14").
follows("l16","l15").
follows("l17","l13").
follows("l17","l16").
follows("l18","l9").
follows("l18","l17").

join("l9","l5","l8").
join("l17","l13","l16").
join("l18","l9","l17").

assign("l4","u","x","0").
assign("l7","u","x","0").
assign("l12","u","y","0").
assign("l15","u","z","0").


if("l2","l3","y","0").
if("l3","l4","z","0").
if("l6","l7","z","0").
if("l10","l11","y","0").
if("l11","l12","z","0").
if("l14","l15","z","0").





.decl candidate( l:label, x: var) 
.output candidate(IO=stdout)

candidate(l, x) :- source( l ,x).
candidate(l, x) :- assign(l,x,y,_), candidate(_,y).
candidate(l, x) :- assign(l,x,_,z), candidate(_,z).
candidate(l, x) :- if(l,_,x,_), candidate(_,x).
candidate(l, x) :- if(l,_,_,x),candidate(_,x).

//candidate(x) :- assign(_,x,y,z), candidate(y),candidate(z). 


.decl labels(i:label )
.output labels(IO=stdout)

labels(l) :- source(l,_).
labels(l) :- follows(l,_).
labels(l) :- follows(_,l).


// .decl stringa(i:label )
// .output stringa(IO=stdout)

// //stringa(l , x) :- labels(substring(m,1,strlen(m)-1))
// stringa(cat("l", substr(x,1,strlen(x)-1))) :- labels(x), strlen(x) > 1.
 

.decl numbers(i:label )
//.output numbers(IO=stdout)
//stringa(l , x) :- labels(substring(m,1,strlen(m)-1))
numbers( substr(x,1,strlen(x)-1) ) :- labels(x), strlen(x) > 1.
 

.decl Less(x:symbol, y:symbol)
Less(x,y) :-numbers(x), numbers(y), ord(x) < ord(y). 

.decl Transitive(x:symbol, y:symbol) 
Transitive(x,z) :-Less(x,y), Less(y,z). 

// .decl Succ(x:symbol, y:symbol) 
// .output Succ(IO=stdout)

// Succ(x,y) :-Less(x,y), !Transitive(x,y).


.decl Succ_letterale(i:label, j:label) // j after i
.output Succ_letterale(IO=stdout)

Succ_letterale(cat("l", x),cat("l", y)) :-Less(x,y), !Transitive(x,y).




.decl loop(i:label, e:label, j:label)
.output loop(IO=stdout)

loop(i,e,j) :- if(i, _ ,x,y), if(e, _ ,x,y), join(j, l ,_), Succ_letterale(l,e), Succ_letterale( l2,i),follows(e, l2) .



// .decl not_candidate(l:label, x:var )
// .output not_candidate(IO=stdout)

// //First non candidate if inside the if of a loop there is more than one different line where the same "x" is
// //a candidate
// not_candidate(l,x) :-  loop(l,l1,l2,_), 
//                         candidate(l4,x), 
//                         candidate(l5,x), 
//                         l4!=l5, 
//                         ord(substr(l1,1,strlen(l1)-1))<ord(substr(l4,1,strlen(l4)-1)),
//                         ord(substr(l1,1,strlen(l1)-1))<ord(substr(l5,1,strlen(l5)-1)),
//                         ord(substr(l4,1,strlen(l4)-1))>ord(substr(l2,1,strlen(l2)-1)),
//                         ord(substr(l5,1,strlen(l5)-1))>ord(substr(l2,1,strlen(l2)-1)),
//                         ord(substr(l4,1,strlen(l4)-1))<ord(substr(l5,1,strlen(l5)-1)).

// 

//

.decl hypothetical_candidate(l:label, x:var )
.output hypothetical_candidate(IO=stdout)
// //TODO: PUT AS "HYPOTHETICAL_CANDIDATE" ALL THOSE LABELS WHERE I HAVE AN IF,
// // AND INSIDE THE IF THERE ARE CANDIDATES...THERE MAY BE EVEN MORE THAN ONE, e.g. if I have two diff so
// urces
// //later used inside the loop
hypothetical_candidate(l,x) :- if(l,_,x,_).

// // hyp_candidate :- given a if(l,...) and the corresponding loop in l, loop(l,e,j) 
// //                              there is a candidate in l2, where l2 is inside the loop: l2<l and l2>j
                                                          

.decl nested_loop(l:label, e:label, j:label )
.output nested_loop(IO=stdout)

// //The following line is: "for all the loops that do not have any loops nested inside..."
// //I would express the condition "there is no loop inside" with the negation "!" but I am not sure
// // it is the correct way.
nested_loop (i1,e1, j1) :- loop(i1,e1,j1), loop(i2,e2,j2), 
            ord(substr(i1,1,strlen(i1)-1))<ord(substr(i2,1,strlen(i2)-1)),
            ord(substr(j2,1,strlen(j2)-1))<ord(substr(e1,1,strlen(e1)-1)).
            //and do not have candidates in both if and else 
            // !(( //There is not a candidate between i-e 
            //     candidate(l1,x) , 
            //     ord(substr(l1,1,strlen(i1)-1))>ord(substr(i1,1,strlen(i1)-1)),
            //     ord(substr(l1,1,strlen(i1)-1))<ord(substr(e1,1,strlen(e1)-1)))
            //     , //or it is not between e-j
            //     (
            //     candidate(l1,x),
            //     ord(substr(l1,1,strlen(i1)-1))>ord(substr(e1,1,strlen(e1)-1)),
            //     ord(substr(l1,1,strlen(i1)-1))<ord(substr(j1,1,strlen(j1)-1)))
            //     ).

.decl internal_loop_with_sanitize(l:label, e:label, j:label ,x:var)
.output internal_loop_with_sanitize(IO=stdout)

internal_loop_with_sanitize (i1,e1, j1, x) :-  loop(i1,e1,j1), !nested_loop(i1,e1,j1),
(( //There is not a candidate between i-e 
                candidate(l1,x) , 
                ord(substr(l1,1,strlen(i1)-1))>ord(substr(i1,1,strlen(i1)-1)),
                ord(substr(l1,1,strlen(i1)-1))<ord(substr(e1,1,strlen(e1)-1)))
                , //or it is not between e-j
                (
                candidate(l2,x),
                ord(substr(l2,1,strlen(l2)-1))>ord(substr(e1,1,strlen(e1)-1)),
                ord(substr(l2,1,strlen(l2)-1))<ord(substr(j1,1,strlen(j1)-1)))
                ).

.decl internal_loop_without_sanitize_both(l:label, e:label, j:label )
.output internal_loop_without_sanitize_both(IO=stdout)

internal_loop_without_sanitize_both (i1, e1, j1) :-  loop(i1,e1,j1), !nested_loop(i1,e1,j1), !internal_loop_with_sanitize (i1,e1, j1, _).

.decl not_candidate(l:label, x:var)
.output not_candidate(IO=stdout)

not_candidate(l,x) :- internal_loop_without_sanitize_both(l,_,_ ), hypothetical_candidate(l,x).
not_candidate(l,x) :- internal_loop_without_sanitize_both(_,l,_ ), hypothetical_candidate(l,x).
not_candidate(l,x) :- nested_loop(i1, e1, j1), (nested_loop(i2, e2, j2) | (internal_loop_with_sanitize)), 


.decl sanitize(l1:label, x: var) 
.output sanitize(IO=stdout)


sanitize(l,x) :- candidate(l,x), sink(_,x).
//sanitize(l,x) :- candidate(_,x), sink(l,x).
sanitize(l,x) :- candidate(_,x), if(l,_,x,_).


.decl 





// -- analysis --