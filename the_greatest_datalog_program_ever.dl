// Authors: Marco Ravazzini & Flavia Cavallaro
//          with the partecipation of Calcutta
//		 <3 <3 Calcutta <3 <3



.type label
.type var
.type opc = [x:number,c:number]
.type opv = [x:number,y:number]
//.type expr //= number | var | opc | opv
//.type cond //= [e:expr,constyp:number]// assume 1 for <, 2 for <= and 3 for ==, 4 for >= and 5 for >

// -- inputs --
.decl source( l:label, x:var )
.decl sink( l:label, x:var ) 
.decl follows( l1:label, l2:label) 

.decl join(l1: label, l2: label, l3:label) 
.decl assign( l:label, x:var, y:var, z:var ) 
.decl if(l1:label, l2:label, x:var, y:var)


//##############################################################################



// /**
// *   The Labels function return the labels that indicates each lines 
// *   (ex. l1, l2 ...)
// */
.decl Labels(i:label )
//.output Labels(IO=stdout)

Labels(l) :- source(l,_).
Labels(l) :- follows(l,_).
Labels(l) :- follows(_,l).


/**
*   The Numbers function strips the labes in order to optain only the number of
*   lines, ignoring the first character 
*/
.decl Numbers(i:symbol )
//.output Numbers(IO=stdout)
Numbers( substr(x,1,strlen(x)-1) ) :- Labels(x), strlen(x) > 1.
 

/**
*   Returns al the lines y that are greater than line x
*/

.decl Less(x:symbol, y:symbol)
//.output Less(IO=stdout)
Less(x,y) :-Numbers(x), Numbers(y), ord(x) < ord(y). 


.decl Transitive(x:symbol, y:symbol) 
//.output Transitive(IO=stdout)
Transitive(x,z) :-Less(x,y), Less(y,z). 


/**
*   Returns the line i with line i+1 (ex. l1  l2, l2  l3 ecc..)
*/
.decl Next_line(i:symbol, j:symbol) // j after i
.output Next_line(IO=stdout)
Next_line(cat("l", i),cat("l", j)) :-Less(i,j), !Transitive(i,j).


// /**
// *   Return the line of the IF, their respective ELse and the Join 
// *   (ex. l2      l10     l18)
// */
// .decl Loop(i:label, e:label, j:label)
// .output Loop(IO=stdout)
// Loop(i,e,j) :- if(i, _ ,x,y), if(e, _ ,x,y), join(j, l ,_), Next_line(l,e), 
//                 Next_line( l2,i),follows(e, l2).


/**
*   The candidate function return all the variables (and the lines in wich they 
*   are declareted) that are dependent from the user's input  direcly or as 
*   reference. Included the conditions of the IF   (ex l1 x, l7 u)
*/


.decl candidate( l:label, x: var) 
.output candidate(IO=stdout)
candidate(l, x) :- source( l ,x).
candidate(l, x) :- assign(l,x,y,_), candidate(_,y).
candidate(l, x) :- assign(l,x,_,z), candidate(_,z).
candidate(l, x) :- if(l,_,x,_), candidate(_,x).
candidate(l, x) :- if(l,_,_,x),candidate(_,x).



.decl smart_loop(i: label, e: label, j: label)
// .output smart_loop(IO=stdout)
smart_loop(i, e, j) :- 
    if(i, _ , a, b), 
    if(e, _ , a, b), i!=e, 
    join(j, q, _),
    ord(q) = ord(e)-1,
    follows(i, l), follows(e, l).

.decl external_if(i:label, e:label, j:label)
// .output external_if(IO=stdout)

external_if(i,e,j) :- smart_loop(i,e,j), smart_loop(i2,_,_), 
            ord(substr(i2,1,strlen(i2)-1)) > ord(substr(i,1,strlen(i)-1)),
            ord(substr(i2,1,strlen(i2)-1)) < ord(substr(j,1,strlen(j)-1)).

.decl internal_if(i:label, e:label, j:label)
// .output internal_if(IO=stdout)

internal_if(i,e,j) :- smart_loop(i,e,j), !external_if(i,e,j).


.decl constant_finder(l:label, y:var, n:var)
// .output constant_finder(IO=stdout)
constant_finder(l,y, x ) :- assign(l,y,x,"0"), match("[0-9]",x).
constant_finder(l,y, x ) :- assign(l,y,"0",x), match("[0-9]",x).

// .decl T1(l:label, x:var )
// .output T1(IO=stdout)
// T1(j1,x) :-  sink(_,x), 
//             assign(l,x,y,_),
//             candidate(_,y),
//             internal_if(l1,e1,j1),
//             ord(substr(l1,1,strlen(l1)-1)) > ord(substr(l,1,strlen(l)-1)),
//             constant_finder(l2,x,_), 
//             ord(substr(l2,1,strlen(l2)-1)) > ord(substr(e1,1,strlen(e1)-1)),
//             ord(substr(l2,1,strlen(l2)-1))  < ord(substr(e1,1,strlen(e1)-1)),
//             !constant_finder(l3,x,_), Labels(l3), l3!=l2,
//             ord(substr(l3,1,strlen(l3)-1)) > ord(substr(e1,1,strlen(e1)-1)),
//             ord(substr(l3,1,strlen(l3)-1)) < ord(substr(j1,1,strlen(j1)-1)).

// T1(e1,x) :-  sink(_,x), 
//             assign(l,x,y,_),
//             candidate(_,y),
//             internal_if(l1,e1,j1), 
//             ord(substr(l1,1,strlen(l1)-1)) > ord(substr(l,1,strlen(l)-1)),
//             !constant_finder(l2,y1,_), Labels(l2),
//             ord(substr(l2,1,strlen(l2)-1)) > ord(substr(l1,1,strlen(l1)-1)),
//             ord(substr(l2,1,strlen(l2)-1)) < ord(substr(e1,1,strlen(e1)-1)),
//             constant_finder(l3,y1,_), Labels(l3),
//             ord(substr(l3,1,strlen(l3)-1)) > ord(substr(e1,1,strlen(e1)-1)),
//             ord(substr(l3,1,strlen(l3)-1)) < ord(substr(j1,1,strlen(j1)-1)).


// cerca i casi dove una variabile su cui viene fatto il sink é assegnata a delle costanti 
// sia nell'if che nell'else e c'é un candidate nelle condizioni dell'if.
// il sink verrá fatto sulla riga dell'if e sulla variabile riconosciuta come candidate
.decl T2(l:label, x:var)
.output T2(IO=stdout)
T2(l,x) :-  sink(_, v), 
            candidate(l, x), 
            internal_if(i1,e1,j1), 
            l = i1,
            assign(p1, v, _, _ ),
            ord(substr(p1,1,strlen(p1)-1)) > ord(substr(i1,1,strlen(i1)-1)),
            ord(substr(p1,1,strlen(p1)-1)) < ord(substr(j1,1,strlen(j1)-1)).
      



// cerca i casi dove una variabile su cui viene fatto il sink é assegnata a una ostante
// nell'if e a un candidate nell'else.
// Il sink verrá fatto sulla riga successiva all'assign candidate.
.decl t3_smart(l:label, x:var)
.output t3_smart(IO=stdout)
t3_smart(l, a) :-   sink(_, v), 
                    assign(l1, a, _, _), 
                    assign(l2, a, _, _),
                    candidate(l2, _ ), 
                    !candidate(l1,_ ), 
                    Next_line(l2, l).
t3_smart(l, a) :-   sink(_, v), 
                    assign(l1, a, _, _), 
                    assign(l2, a, _, _),
                    !candidate(l2, _ ), 
                    candidate(l1,_ ), 
                    Next_line(l1, l).
// In teoria il caso 1, copre i casi in cui sopra UN If-else c'è un assign, in realtà non funziona
//bene per motivi ignoti.
//Invece questo test copre i casi in cui sopra l'if non ci sono assignments.

.decl T3(l:label, x:var)
.output T3(IO=stdout)
T3(lf,y) :- Next_line(l1,lf),
            sink(_,y), smart_loop(i1,e1,j1), !assign(l,y,x,_),candidate(_,x), Labels(l),
            ord(substr(l,1,strlen(l)-1)) > ord(substr(i1,1,strlen(i1)-1)),
            ord(substr(l,1,strlen(l)-1)) < ord(substr(e1,1,strlen(e1)-1)),
            assign(l1,y,x,_),
            ord(substr(l1,1,strlen(l1)-1)) > ord(substr(e1,1,strlen(e1)-1)),
            ord(substr(l1,1,strlen(l1)-1)) < ord(substr(j1,1,strlen(j1)-1)).
            
T3(lf,y) :- Next_line(l1,lf),
            sink(_,y), smart_loop(i1,e1,j1), assign(l,y,x,_),candidate(_,x), Labels(l),
            ord(substr(l,1,strlen(l)-1)) > ord(substr(i1,1,strlen(i1)-1)),
            ord(substr(l,1,strlen(l)-1)) < ord(substr(e1,1,strlen(e1)-1)),
            !assign(l1,y,x,_),Labels(l1),
            ord(substr(l1,1,strlen(l1)-1)) > ord(substr(e1,1,strlen(e1)-1)),
            ord(substr(l1,1,strlen(l1)-1)) < ord(substr(j1,1,strlen(j1)-1)).

.decl T4(l:label, x:var)
.output T4(IO=stdout)

//T4(l,x) :- sink(l,x) ,sink(l1,y), (assign(_,x,y,_) ; (assign(_,x,_,y))).
T4(ld,x) :- sink(_,x), source(l,x), !assign(l1,x,_,_), Labels(l1), Next_line(l,ld). 

// .decl T5(l:label, x:var)
// .output T5(IO=stdout)
