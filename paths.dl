// don't remove this comment 
.type label
.type var
.type opc = [x:number,c:number]
.type opv = [x:number,y:number]
//.type expr //= number | var | opc | opv
//.type cond //= [e:expr,constyp:number]// assume 1 for <, 2 for <= and 3 
// for ==, 4 for >= and 5 for >

// -- inputs --
.decl source( l:label, x:var )
.decl sink( l:label, x:var ) 
.decl follows( l1:label, l2:label) 

.decl join(l1: label, l2: label, l3:label) 
.decl assign( l:label, x:var, y:var, z:var ) 
.decl if(l1:label, l2:label, x:var, y:var)



.decl reachable(l:label, j:label)
// .output reachable(IO=stdout)
reachable(X,Y)  :-  follows(X,Y).
reachable(X,Y)  :-  reachable(X,Z), follows(Z,Y).

.decl if_paths(l:label, j:label)
//.output if_paths(IO=stdout)
if_paths(l,j) :- join(l,j,_).
if_paths(l,j) :- if_paths(l,x), reachable(x,j).

.decl else_paths(l:label, j:label)
//.output else_paths(IO=stdout)
else_paths(l,j) :- join(l,_,j).
else_paths(l,j) :- else_paths(l,x), reachable(x,j).


.decl Labels(i:label )
// .output Labels(IO=stdout)
Labels(l) :- source(l,_).
Labels(l) :- follows(l,_).
Labels(l) :- follows(_,l).

.decl candidate( l:label, x: var) 
// .output candidate(IO=stdout)
candidate(l, x) :- source( l ,x).
candidate(l, x) :- assign(l,x,y,_), candidate(_,y).
candidate(l, y) :- assign(l,_,y,_), candidate(_,y).
candidate(l, x) :- assign(l,x,_,z), candidate(_,z).
candidate(l, z) :- assign(l,_,_,z), candidate(_,z).
candidate(l, x) :- ( if(l,_,x,_);if(l,_,_,x)), candidate(_,x).


/*
    Return three labels corresponding to the location of the if-else-join of each if-else.
*/
.decl if_else_finder(i:label, e:label, j:label) 
//.output if_else_finder(IO=stdout)
if_else_finder(i,e,j) :- if(i, _ ,x,y), if(e, _ ,x,y), join(j, ij ,ej), 
                !follows(e, ij), 
                follows(j, ej), 
                i != e, 
                reachable(ij, i), 
                reachable(ej, e),
                follows(i, l2), follows(e, l2).


/*
    In order to decide whether to sanitize the right hand side variables or the left hand side variables, we made the
    following assumption: If there is a varaible in the sink that depends on two sources (double-source assignment),
    then do the sanitization on the left hand side, otherwise do it on the right hand side. 
    The previous assumption has only one exception: If one of the variables used in the "double" assignment is also
    in a sink, then do it on the right hand side varaibles.
*/
.decl left_flag(l:symbol)
//.output left_flag(IO=stdout)
left_flag(flag) :- flag="left", assign(_,_,a,b), candidate(_,a), candidate(_,b), !sink(_,a), !sink(_,b).


.decl right_flag(l:symbol)
//.output right_flag(IO=stdout)
right_flag(flag) :- flag="right", c = count:{left_flag(_)}, c<1.


/*
    All the variables that are used in a sink method.
*/
.decl to_check(  x: var) 
//.output to_check(IO=stdout)
to_check( x) :- sink( _ ,x).


/* 
    Given a source v, that is present also in a sink, the following function finds if there is a path
    realted to the if_label 'i', where this variable v is assigned to something else (label l).
    This rule will be used later to find the opposite.
*/
.decl source_sink_assigned_in_a_path(i:label, l:label, v:var)
//.output source_sink_assigned_in_a_path(IO=stdout)

source_sink_assigned_in_a_path(if_label,j,v ) :- source(_,v), sink(_,v), if_paths(join_label, j),
                                        if_else_finder(if_label, _, join_label),
                                        ( assign(j,v,d,_); assign(j,v,_,d) ).
source_sink_assigned_in_a_path(else_label,j,v ) :- source(_,v), sink(_,v), else_paths(join_label, j),
                                        if_else_finder(_,else_label , join_label),
                                        ( assign(j,v,d,_); assign(j,v,_,d) ).


/*
    Given a source v, that is present also in a sink, the following function finds all those paths
    where the variable is NOT assigned.
    This rule is used to set the dependency of the variable to itself in the label following the if_label or the 
    else_label 'l'.
*/
.decl source_sink_NOT_assigned_in_a_path(i:label, l:label, v:var)
//.output source_sink_NOT_assigned_in_a_path(IO=stdout)

source_sink_NOT_assigned_in_a_path(if_label, l, v) :- source(_,v), sink(_,v), if(if_label,l,_,_),
                                        if_else_finder(if_label, _, _),
                                        !source_sink_assigned_in_a_path(if_label,_,v).

source_sink_NOT_assigned_in_a_path(else_label, l, v) :- source(_,v), sink(_,v), if(else_label,l,_,_),
                                        if_else_finder(_,else_label, _),
                                        !source_sink_assigned_in_a_path(else_label,_,v).


/*  
    It may happen that a variable (not a source), used in a sink method, is assigned in a path, but not assigned
    in another path.
*/
.decl var_in_sink_assigned_in_a_path(i:label, l:label, v:var)
//.output var_in_sink_assigned_in_a_path(IO=stdout)

var_in_sink_assigned_in_a_path(if_label,j,v ) :-   sink(_,v), if_paths(join_label, j), 
                                                reachable(j,if_label), /*Only counts assignments
                                                                        after the if */
                                                if_else_finder(if_label, _, join_label),
                                                ( assign(j,v,d,_); assign(j,v,_,d) ).

var_in_sink_assigned_in_a_path(else_label,j,v ) :-  sink(_,v), else_paths(join_label, j),
                                                    reachable(j,else_label),
                                                    if_else_finder(_,else_label , join_label),
                                                    ( assign(j,v,d,_); assign(j,v,_,d) ).


.decl var_in_sink_NOT_assigned_in_a_path(i:label, l:label, v:var)
//.output var_in_sink_NOT_assigned_in_a_path(IO=stdout)

var_in_sink_NOT_assigned_in_a_path(if_label, l, v) :- sink(_,v), if(if_label,l,_,_),
                                        if_else_finder(if_label, _, _),
                                        !var_in_sink_assigned_in_a_path(if_label,_,v).

var_in_sink_NOT_assigned_in_a_path(else_label, l, v) :- sink(_,v), if(else_label,l,_,_),
                                        if_else_finder(_,else_label, _),
                                        !var_in_sink_assigned_in_a_path(else_label,_,v).



/*
    Finds all the if_else_join labels of tbe if-else, that HAVE other if-else nested.
*/
.decl external_if(i:label, e:label, j:label)
//.output external_if(IO=stdout)
external_if(l1,e,j) :- if(l0,_,_,_), if(l1,_,_,_), reachable(l0,l1), if_else_finder(l1,e,j).


/*
    Find all the if_else_join labels of the if-else that DOES NOT HAVE an if-else nested.
*/
.decl internal_if(i:label, e:label, j:label)
//.output internal_if(IO=stdout)
internal_if(l,e,j) :- if_else_finder(l,e,j), !external_if(l,_,_).



/*
    Given a label l, find the immediate predecessor 'if' to which that label belongs.
*/
.decl belonging_if(j:label, l:label) /* Label l belongs to if in label j */
// .output belonging_if(IO=stdout)
belonging_if(j,l) :- (internal_if(j,_,_);internal_if(_,j,_)), assign(l,_,_,_), if(j,_,_,_), reachable(l,j).



/*  
    Given a if-else-join in label i, 
    given a variable v in label l, that belongs to 
    the path of that if-else, it finds a dependency d
*/ 

.decl dependencies_if(i:label, l:label, v:var, d:var ) 
//.output dependencies_if(IO=stdout)


/*  ---------------------------------------------------------------------------------------
*   THESE THREE DEPENDENCIES ARE MADE IN CASE WE TAKE THE RIGHT HAND SIDE DEPENDENCIES
*   ---------------------------------------------------------------------------------------
*/

/*
    Given an assign of v, in the label j, of the dependency d, where d is a 'candidate' before that assign.
    (Being a 'candidate' before that assign means that: d is a source or something that had a source assigned before that label j).
    Therefore, put the dependcy in the corresponding if_label.
*/
dependencies_if(if_label,j,v,d ) :-   if_paths(join_label, j), /*Given a path (join_label, l0...li).*/
                                    belonging_if(if_label,j), /*Takes only the belonging if of the assign */
                                    reachable(j,if_label), /*It is used to check that the assignment
                                                            happens inside the if, and not outside.
                                                            */
                                    if_else_finder(if_label, _, join_label), /*Used to retrieve the if
                                                                                belonging to that join_label
                                                                                */
                                    ( assign(j,v,d,_); assign(j,v,_,d) ),  /*There has to be an assign v = d ...
                                                                            where v is the variable to sink and
                                                                            d the dependency
                                                                            */
                                    candidate(l,d), reachable(j,l) , /* The dependency d, which is a 'candidate'
                                                                        can be wherever BUT it has to be 
                                                                        reachable from the 'path_labels',
                                                                        this mean  that has to be above */                                                                      
                                    var_in_sink_assigned_in_a_path(if_label, _, v), /* The variable v has to be assigned in this 
                                                                                        path, otherwise the next rule has to be used.
                                                                                        */
                                    sink(_,v), c = count:{left_flag(_)}, c<1.   /*Has to be in the sink and we have to be in the
                                                                                 "right-hand" side mode.
                                                                                */


/*  There may a case where a variable v, requested in a sink method, is assigned to something else in a 
    path (eg. in the if path) but not assigned in another path (eg. the else path).
    If that variable was assigned to something else before the if-path, then the else path has to take it 
    into account. This function therefore sets this dependency.
*/
 dependencies_if(if_label,j,v,d ) :-    if_paths(join_label, j), /*Given a path (join_label, l0...li).*/ 
                                        if_else_finder(if_label, _, join_label), 
                                        (assign(l,v,d,_);assign(l,v,_,d)), /* Given an assign... */
                                        follows(jf, if_label), /*To put the dependency on the label
                                                                following the if_label
                                                                */
                                        reachable(j,l) ,    /*  That has still to be in the path, 
                                                                but doesn't matter that it is after the if_label */
                                        candidate(l1,d), reachable(j,l1), /*  Where d is a candidate
                                                                            belonging to the path as well
                                                                        */
                                        var_in_sink_NOT_assigned_in_a_path(if_label, _, v),
                                        sink(_,v), c = count:{left_flag(_)}, c<1.
                              
/* 
    Used to create the dependcy of a variable from the candidates in an if 
*/
dependencies_if(ls,j,v,d ) :-  if_paths(join_label, j), belonging_if(ls, j),
                                    if_paths(join_label, l), ( if(l,_,d,_);if(l,_,_,d)), 
                                    assign(j,v,_,_), candidate(l,d),  v!=d,
                                    sink(_,v), c = count:{left_flag(_)}, c<1.

/*  ---------------------------------------------------------------------------------------
*   THESE  DEPENDENCy is MADE IN CASE WE TAKE THE LEFT HAND SIDE DEPENDENCIES
*   ---------------------------------------------------------------------------------------
*/dependencies_if(if_label,j,v,v ) :-   if_paths(join_label, j), 
                                    if_else_finder(if_label, _, join_label),
                                    ( assign(j,v,d,_); assign(j,v,_,d) ), 
                                    candidate(l,d), reachable(j,l),
                                    sink(_,v), c = count:{left_flag(_)}, c>0.


/* 
    The following function is used in the case where there is a source, used at the end in a sink method.
    Given two paths, a and b, it may happen that x is assigned to something in a but not assigned in b, therefore
    in b has to be sanitized. The dependency is created of "itself".

*/
dependencies_if(if_label,j,v,v ) :- source_sink_NOT_assigned_in_a_path(if_label, j, v),
                                    if_paths(join_label, j), 
                                    if_else_finder(if_label, _, join_label).
  

/*
    To make things more schematic same things are done for the else cases 
*/


.decl dependencies_else(i:label, l:label, v:var, d:var )  //variable v in label l, depends on d.
//.output dependencies_else(IO=stdout)

/* THESE DEPENDENCIES ARE MADE IN CASE WE TAKE THE RIGHT HAND SIDE DEPENDENCIES */

dependencies_else(else_label,j,v,d ) :-  else_paths(join_label, j), reachable(j,else_label),
                                        //belonging_if(if_label,j),
                                        if_else_finder(if_label, else_label, join_label),
                                        ( assign(j,v,d,_); assign(j,v,_,d) ),
                                        candidate(l,d), reachable(j,l),
                                        var_in_sink_assigned_in_a_path(else_label, _, v),
                                        sink(_,v),c = count:{left_flag(_)}, c<1.

dependencies_else(else_label,j,v,d ) :-  else_paths(join_label, j),
                                        if_else_finder(_, else_label, join_label),
                                        else_paths(join_label, l),( if(l,_,d,_);if(l,_,_,d)), 
                                        assign(j,v,_,_), candidate(l,d),  v!=d,
                                        sink(_,v), c = count:{left_flag(_)}, c<1.


 dependencies_else(else_label,jf,v,v ) :-    else_paths(join_label, j), /*Given a path (join_label, l0...li).*/ 
                                        if_else_finder( _,else_label, join_label), 
                                        follows(jf, else_label), /*Used to put the dependency 
                                                                on the label following the else_label
                                                                */
                                        (assign(l,v,d,_);assign(l,v,_,d)), /* Given an assign... */
                                        reachable(j,l) ,    /*  That has still to be in the path, 
                                                                but doesn't matter that it is after the if_label */
                                        ( assign(l1,v,d,_);assign(l1,v,_,d)), reachable(j,l1), /*  Where d is a candidate
                                                                            belonging to the path as well
                                                                        */
                                        candidate(lll,d), reachable(l1,lll),
                                        var_in_sink_NOT_assigned_in_a_path(else_label, _, v),
                                        /*
                                        Necesserly, the sanitize has to be made in that body at the end of the left
                                        hand side variable. 
                                        */
                                        sink(_,v), c = count:{left_flag(_)}, c<1.
                              

dependencies_else(else_label,j,v,v ) :- source_sink_NOT_assigned_in_a_path(else_label, j, v),
                                    else_paths(join_label, j), belonging_if(else_label,j),
                                    if_else_finder(_, else_label,  join_label).
           




/* THESE DEPENDENCY IS MADE IN CASE WE TAKE THE LEFT HAND SIDE DEPENDENCIES */

dependencies_else(else_label,j,v,v ) :-  else_paths(join_label, j),
                                        belonging_if(else_label,j),
                                        if_else_finder(_, else_label, join_label),
                                        ( assign(j,v,d,_); assign(j,v,_,d) ),
                                        candidate(l,d), reachable(j,l),
                                        sink(_,v),c = count:{left_flag(_)}, c>0.


.decl most_external_if(i:label, e:label, j:label)
//.output most_external_if(IO=stdout)
most_external_if(i,e,j) :- external_if(i,e,j), !external_if(i2,_,_), reachable(i,i2).

/*

.decl external_if(i:label, e:label, j:label)  Label of the if-else if it's the case 
.decl internal_if(i:label, e:label, j:label) 
.decl belonging_if(j:label, l:label)  Label l belongs to if in label j 
.decl dependencies_if(i:label, l:label, v:var, d:var ) 
.decl dependencies_else(i:label, l:label, v:var, d:var )  /variable v in label l, depends on d.
*/

.decl dependencies(i:label, l:label, v:var, d:var )
// .output dependencies(IO=stdout)
dependencies(i,l,v,d) :- dependencies_if(i,l,v,d).
dependencies(i,l,v,d) :- dependencies_else(i,l,v,d).


.decl not_candidate(l:label, v:var)
// .output not_candidate(IO=stdout)
not_candidate(l, v) :- assign(l, v, _, _), !candidate(l,_).


//FIXME: specify that the not_candidate line has to be after the candidate line
.decl sanitize_no_if(l:label, v:var)
// .output sanitize_no_if(IO=stdout)
sanitize_no_if(l,b) :- !if(_,_,_,_), 
                            sink(l, b), 
                            candidate(s, b), 
                            !assign(s, _, b, _), !assign(s, _, _, b),
                            !not_candidate(_, b).


// !assign(p, b, _, _), Labels(p) , !candidate(p,b),  !assign(s, _, b, _), !assign(s, _, _, b)

/*
First sanitize: for the non nested loop, to make it easier. for now

*/
.decl first_sanitize(l:label, d:var)
.output first_sanitize(IO=stdout)

first_sanitize(l,d) :- sanitize_no_if(l,d).

/* 1a, 2a, 3a: CASES FOR RIGHT HAND SANITIZE */
/* 1a- CASE:
    The dependency on variable d is in both if-else
*/
first_sanitize(i,d) :- internal_if(i,e,_), counter1 = count:{external_if(_,_,_)}, counter1 <1, 
            /*Given an internal if, CASE WHERE THERE AREN'T NESTED LOOPS */
                        dependencies(i,_,_,d), dependencies(e,_,_,d),
                        counter2 = count:{left_flag(_)}, counter2<1. /*RIGHT-HAND-SIDE CASE*/
/* 2a- CASE:
    The dependency on variable d is in only in if
*/
first_sanitize(m,d) :- internal_if(i,e,_), counter1 = count:{external_if(_,_,_)}, counter1 <1, 
            /*Given an internal if, CASE WHERE THERE AREN'T NESTED LOOPS */
                        follows(m,i),
                        dependencies(i,_,_,d), !dependencies(e,_,_,d),
                        counter2 = count:{left_flag(_)}, counter2<1. /*RIGHT-HAND-SIDE CASE*/
/* 3a- CASE:
    The dependency on variable d is in only in else
*/
first_sanitize(m,d) :- internal_if(i,e,_), counter1 = count:{external_if(_,_,_)}, counter1 <1, 
            /*Given an internal if, CASE WHERE THERE AREN'T NESTED LOOPS */
                        follows(m,e),
                        !dependencies(i,_,_,d), dependencies(e,_,_,d),
                        counter2 = count:{left_flag(_)}, counter2<1. /*RIGHT-HAND-SIDE CASE*/


/* 1b, 2b, 3b: CASES FOR LEFT HAND SANITIZE */
/* 1b- CASE:
    The dependency on variable d is in both if-else
*/
first_sanitize(j,d) :- internal_if(i,e,j), counter1 = count:{external_if(_,_,_)}, counter1 <1, 
            /*Given an internal if, CASE WHERE THERE AREN'T NESTED LOOPS */
                        dependencies(i,_,_,d), dependencies(e,_,_,d),
                        counter2 = count:{left_flag(_)}, counter2>0. /*RIGHT-HAND-SIDE CASE*/
/* 2a- CASE:
    The dependency on variable d is in only in if
*/
first_sanitize(m,d) :- internal_if(i,e,_), counter1 = count:{external_if(_,_,_)}, counter1 <1, 
            /*Given an internal if, CASE WHERE THERE AREN'T NESTED LOOPS */
                        follows(m,l),
                        dependencies(i,l,_,d), !dependencies(e,_,_,d),
                        counter2 = count:{left_flag(_)}, counter2>0. /*RIGHT-HAND-SIDE CASE*/
/* 3a- CASE:
    The dependency on variable d is in only in else
*/
first_sanitize(m,d) :- internal_if(i,e,_), counter1 = count:{external_if(_,_,_)}, counter1 <1, 
            /*Given an internal if, CASE WHERE THERE AREN'T NESTED LOOPS */
                        follows(m,l),
                        !dependencies(i,_,_,d), dependencies(e,l,_,d),
                        counter2 = count:{left_flag(_)}, counter2>0. /*RIGHT-HAND-SIDE CASE*/


/*  _______________________________________________________________________________________________________________
/*  ---------------------------------------------------------------------------------------------------------------
                                            FOR NESTED IF-ELSE
       ----    ----    ----    ----    ----    ----    ----    ----    ----    ----    ----    ----    ----    ----
*/
/*

.decl external_if(i:label, e:label, j:label)  Label of the if-else if it's the case 
.decl internal_if(i:label, e:label, j:label) 
.decl belonging_if(j:label, l:label)  Label l belongs to if in label j 
.decl dependencies_if(i:label, l:label, v:var, d:var ) 
.decl dependencies_else(i:label, l:label, v:var, d:var )  /variable v in label l, depends on d.
*/
.decl not_successive_if(i:label, j:label)
//.output not_successive_if(IO=stdout)
not_successive_if(i0,i2) :- if(i0,_,_,_), if(i1,_,_,_), if(i2,_,_,_),
                            reachable(i2,i0), reachable(i2,i1), reachable(i1,i0),
                            !reachable(i0,i1), !reachable(i1,i2),
                            if_else_finder(i2,_,_).




.decl successive_if(i:label, j:label) /*The if in label i is the successive if of the if in label j*/
//.output successive_if(IO=stdout)
successive_if(i0,i2) :- if(i0,_,_,_), if(i2,_,_,_), reachable(i2,i0),
                        if_else_finder(i2,_,_), !not_successive_if(i0,i2).

// .decl successive_if(i:label, j:label) /*The if in label i is the successive if of the if in label j*/
// .output successive_if(IO=stdout)
// successive_if(i0,i2) :- if(i0,_,_,_), !if(i1,_,_,_), if(i2,_,_,_), reachable(i2,i0),
//                         reachable(i1,i0), !reachable(i0,i1), !reachable(i0,i2), 
//                         if_else_finder(i2,_,_), !not_successive_if(i0,i2).



.decl new_dependencies(l:label, d:var)
// .output new_dependencies(IO=stdout)
/*-----------------------------------------------------------------------------------------------------------
/* IF CASE: RECURSIVE, FOR MORE THAN 2 NESTED IF-ELSE
/*RIGHT-HAND-SIDE: Case */

//1a: The dependency on variable d is in both if-else
new_dependencies(i1,d) :-     external_if(i1,_,j1), external_if(i2,e2,j2), successive_if(i2,i1),
                              (new_dependencies(i2,d); dependencies(i2,_,_,d)),
                                ( new_dependencies(e2,d);dependencies(e2,_,_,d) ),
                             counter2 = count:{left_flag(_)}, counter2<1. /*RIGHT-HAND-SIDE CASE*/

//2a: The dependency on variable d is in only in if
// new_dependencies(i2,d) :-     external_if(i1,_,j1), external_if(i2,e2,j2), successive_if(i2,i1),
//                              new_dependencies(i2,d), !new_dependencies(e2,d),
//                              counter2 = count:{left_flag(_)}, counter2<1. /*RIGHT-HAND-SIDE CASE*/

// //3a: The dependency on variable d is in only in else
// new_dependencies(e2,d) :-     external_if(i1,_,j1), external_if(i2,e2,j2), successive_if(i2,i1),
//                              !new_dependencies(i2,d), new_dependencies(e2,d),
//                              counter2 = count:{left_flag(_)}, counter2<1. /*RIGHT-HAND-SIDE CASE*/

// /*LEFT-HAND-SIDE: Case */
//1a: The dependency on variable d is in both if-else
new_dependencies(j2,d) :-     external_if(i1,_,_), external_if(i2,e2,j2), successive_if(i2,i1),
                             new_dependencies(i2,d), new_dependencies(e2,d),
                             counter2 = count:{left_flag(_)}, counter2>0. /*LEFT-HAND-SIDE CASE*/

// //2a: The dependency on variable d is in only in if
// new_dependencies(ls,d) :-     external_if(i1,_,j1), external_if(i2,e2,j2), successive_if(i2,i1),
//                              new_dependencies(i2,d), !new_dependencies(e2,d), join(ls,_,j2),
//                              counter2 = count:{left_flag(_)}, counter2>0. /*LEFT-HAND-SIDE CASE*/

// //3a: The dependency on variable d is in only in else
// new_dependencies(ls,d) :-     external_if(i1,_,j1), external_if(i2,e2,j2), successive_if(i2,i1),
//                              !new_dependencies(i2,d), new_dependencies(e2,d), join(_,ls,j2),
//                              counter2 = count:{left_flag(_)}, counter2>0. /*LEFT-HAND-SIDE CASE*/


/* ELSE CASE: RECURSIVE, FOR MORE THAN 2 NESTED IF-ELSE
// /*LEFT-HAND-SIDE: Case */
//1a: The dependency on variable d is in both if-else
new_dependencies(e1,d) :-     external_if(_,e1,_), external_if(i2,e2,_), successive_if(e1,i2),
                             new_dependencies(i2,d), new_dependencies(e2,d),
                             counter2 = count:{left_flag(_)}, counter2<1. /*RIGHT-HAND-SIDE CASE*/

// //2a: The dependency on variable d is in only in if
// new_dependencies(i2,d) :-     external_if(i1,e1,j1), external_if(i2,e2,j2), successive_if(e1,i2),
//                              new_dependencies(i2,d), !new_dependencies(e2,d),
//                              counter2 = count:{left_flag(_)}, counter2<1. /*RIGHT-HAND-SIDE CASE*/

// //3a: The dependency on variable d is in only in else
// new_dependencies(e2,d) :-     external_if(i1,e1,j1), external_if(i2,e2,j2), successive_if(e1,i2),
//                              !new_dependencies(i2,d), new_dependencies(e2,d),
//                              counter2 = count:{left_flag(_)}, counter2<1. /*RIGHT-HAND-SIDE CASE*/

// /*LEFT-HAND-SIDE: Case */
//1a: The dependency on variable d is in both if-else
new_dependencies(j2,d) :-     external_if(_,e1,_), external_if(i2,e2,j2), successive_if(e1,i2),
                             new_dependencies(i2,d), new_dependencies(e2,d),
                             counter2 = count:{left_flag(_)}, counter2>0. /*LEFT-HAND-SIDE CASE*/

// //2a: The dependency on variable d is in only in if
// new_dependencies(ls,d) :-     external_if(i1,e1,j1), external_if(i2,e2,j2), successive_if(e1,i2),
//                              !new_dependencies(i2,d), new_dependencies(e2,d), join(ls,_,j2),
//                              counter2 = count:{left_flag(_)}, counter2>0. /*LEFT-HAND-SIDE CASE*/

// //3a: The dependency on variable d is in only in else
// new_dependencies(ls,d) :-     external_if(i1,e1,j1), external_if(i2,e2,j2), successive_if(e1,i2),
//                              new_dependencies(i2,d), !new_dependencies(e2,d), join(_,ls,j2),
//                              counter2 = count:{left_flag(_)}, counter2>0. /*LEFT-HAND-SIDE CASE*/




/*-----------------------------------------------------------------------------------------------------------
/* IF CASE
/*RIGHT-HAND-SIDE: Case when we arrive at the "last" level, when the external if has only the internal if inside*/
new_dependencies(i2,d) :-    external_if(i1,_,_), internal_if(i2,e2,_), successive_if(i1,i2),
                            dependencies(i2,_,_,d), dependencies(e2,_,_,d),
                            counter2 = count:{left_flag(_)}, counter2<1. /*RIGHT-HAND-SIDE CASE*/

new_dependencies(ls,d) :-    external_if(i1,_,_), internal_if(i2,e2,_), successive_if(i1,i2), follows(ls,i2),
                            dependencies(i2,_,_,d), !dependencies(e2,_,_,d),
                            counter2 = count:{left_flag(_)}, counter2<1. /*RIGHT-HAND-SIDE CASE*/


new_dependencies(ls,d) :-    external_if(i1,_,_), internal_if(i2,e2,_), successive_if(i1,i2), follows(ls,e2),
                            !dependencies(i2,_,_,d), dependencies(e2,_,_,d),
                            counter2 = count:{left_flag(_)}, counter2<1. /*RIGHT-HAND-SIDE CASE*/

/*LEFT-HAND-SIDE: Case when we arrive at the "last" level, when the external if has only the internal if inside*/
new_dependencies(j2,d) :-    external_if(i1,_,_), internal_if(i2,e2,j2), successive_if(i1,i2),
                            dependencies(i2,_,_,d), dependencies(e2,_,_,d),
                            counter2 = count:{left_flag(_)}, counter2>0. /*LEFT-HAND-SIDE CASE*/

new_dependencies(ls,d) :-    external_if(i1,_,_), internal_if(i2,e2,_), successive_if(i1,i2),
                            dependencies(i2,l,_,d), !dependencies(e2,_,_,d), follows(ls,l),
                            counter2 = count:{left_flag(_)}, counter2>0. /*LEFT-HAND-SIDE CASE*/


new_dependencies(ls,d) :-    external_if(i1,_,_), internal_if(i2,e2,_), successive_if(i1,i2),
                            !dependencies(i2,_,_,d), dependencies(e2,l,_,d), follows(ls,l),
                            counter2 = count:{left_flag(_)}, counter2>0. /*LEFT-HAND-SIDE CASE*/

/*-----------------------------------------------------------------------------------------------------------
/* ELSE CASE
*/
/*RIGHT-HAND-SIDE: */
new_dependencies(e1,d) :-    external_if(_,e1,_), internal_if(i2,e2,_), successive_if(e1,i2),
                            dependencies(i2,_,_,d), dependencies(e2,_,_,d),
                            counter2 = count:{left_flag(_)}, counter2<1. /*RIGHT-HAND-SIDE CASE*/

new_dependencies(ls,d) :-    external_if(_,e1,_), internal_if(i2,e2,_), successive_if(e1,i2),follows(ls,i2),
                            dependencies(i2,_,_,d), !dependencies(e2,_,_,d),
                            counter2 = count:{left_flag(_)}, counter2<1. /*RIGHT-HAND-SIDE CASE*/


new_dependencies(ls,d) :-    external_if(_,e1,_), internal_if(i2,e2,_), successive_if(e1,i2),follows(ls,e2),
                            !dependencies(i2,_,_,d), dependencies(e2,_,_,d),
                            counter2 = count:{left_flag(_)}, counter2<1. /*RIGHT-HAND-SIDE CASE*/

/*LEFT-HAND-SIDE: Case when we arrive at the "last" level, when the external if has only the internal if inside*/
new_dependencies(j2,d) :-    external_if(_,e1,_), internal_if(i2,e2,j2), successive_if(e1,i2),
                            dependencies(i2,_,_,d), dependencies(e2,_,_,d),
                            counter2 = count:{left_flag(_)}, counter2>0. /*LEFT-HAND-SIDE CASE*/

new_dependencies(ls,d) :-    external_if(_,e1,_), internal_if(i2,e2,_), successive_if(e1,i2),
                            dependencies(i2,l,_,d), !dependencies(e2,_,_,d), follows(ls,l),
                            counter2 = count:{left_flag(_)}, counter2>0. /*LEFT-HAND-SIDE CASE*/


new_dependencies(ls,d) :-    external_if(_,e1,_), internal_if(i2,e2,_), successive_if(e1,i2),
                            !dependencies(i2,_,_,d), dependencies(e2,l,_,d), follows(ls,l),
                            counter2 = count:{left_flag(_)}, counter2>0. /*LEFT-HAND-SIDE CASE*/







// .decl second_sanitize(l1:label, l:label, d:var)
// .output second_sanitize(IO=stdout)
// second_sanitize(i1, i1, d) :- internal_if(i1, e1, _), 
//                                 dependencies(i1,_,_,d), 
//                                 dependencies(e1,_,_,d),
//                                 successive_if(i2, i1),
//                                 second_sanitize(i2,i1,d).
// second_sanitize(i1, i1, v) :- !internal_if(i1, e1, _), 
//                                 if_else_finder(i1, e1, j1),
//                                 candidate(_, v),
//                                 !dependencies(e1,_,_,v).



// .decl omg(l:label, x:number)
// .output minT(IO=stdout)

// omg("l1", 1).
// omg("l1", 2).
// omg("l1", 3).
// .decl minT(l:label, n:number)
// .output minT(IO=stdout)
// minT(l, min x:{omg(l, x)}) :- omg(l,x) .


// second_sanitize(i,d) :- most_external_if(i,e,j), counter1 = count:{external_if(_,_,_)}, counter1 >0, 
//                        new_dependencies(i,_,_,d), new_dependencies(e,_,_,d),
//                        counter2 = count:{left_flag(_)}, counter2<1. /*RIGHT-HAND-SIDE CASE*/
// /* 2a- CASE:
//     The dependency on variable d is in only in if
// */
// second_sanitize(i,d) :- most_external_if(i,e,j), counter1 = count:{external_if(_,_,_)}, counter1 >0, 
//                         follows(m,i),
//                         new_dependencies(i,_,_,d), !new_dependencies(e,_,_,d),
//                         counter2 = count:{left_flag(_)}, counter2<1. /*RIGHT-HAND-SIDE CASE*/
// /* 3a- CASE:
//     The dependency on variable d is in only in else
// */
// second_sanitize(i,d) :- most_external_if(i,e,j), counter1 = count:{external_if(_,_,_)}, counter1 >0, 
//                         follows(m,e),
//                         !new_dependencies(i,_,_,d), new_dependencies(e,_,_,d),
//                         counter2 = count:{left_flag(_)}, counter2<1. /*RIGHT-HAND-SIDE CASE*/




// /* 1b, 2b, 3b: CASES FOR LEFT HAND SANITIZE */
// /* 1b- CASE:
//     The dependency on variable d is in both if-else
// */

// second_sanitize(j,d) :- most_external_if(i,e,j), counter1 = count:{external_if(_,_,_)}, counter1 >0, 
//                         new_dependencies(i,_,_,d), new_dependencies(e,_,_,d),
//                         counter2 = count:{left_flag(_)}, counter2>0. /*RIGHT-HAND-SIDE CASE*/
// /* 2a- CASE:
//     The dependency on variable d is in only in if
// */
// second_sanitize(m,d) :- most_external_if(i,e,j), counter1 = count:{external_if(_,_,_)}, counter1 >0, 
//                         follows(m,l),
//                         new_dependencies(i,l,_,d), !new_dependencies(e,_,_,d),
//                         counter2 = count:{left_flag(_)}, counter2>0. /*RIGHT-HAND-SIDE CASE*/
// /* 3a- CASE:
//     The dependency on variable d is in only in else
// */
// second_sanitize(m,d) :- most_external_if(i,e,j), counter1 = count:{external_if(_,_,_)}, counter1 >0, 
//                         follows(m,l),
//                         !new_dependencies(i,_,_,d), new_dependencies(e,l,_,d),
//                         counter2 = count:{left_flag(_)}, counter2>0. /*RIGHT-HAND-SIDE CASE*/




